/*
ConfigCat Public Management API

The purpose of this API is to access the ConfigCat platform programmatically. You can **Create**, **Read**, **Update** and **Delete** any entities like **Feature Flags, Configs, Environments** or **Products** within ConfigCat.  **Base API URL**: https://test-api.configcat.com  If you prefer the swagger documentation, you can find it here: [Swagger UI](https://test-api.configcat.com/swagger).  The API is based on HTTP REST, uses resource-oriented URLs, status codes and supports JSON  format. Do not use this API for accessing and evaluating feature flag values. Use the [SDKs instead](https://configcat.com/docs/sdk-reference/overview).   # OpenAPI Specification  The complete specification is publicly available in the following formats:  - [OpenAPI v3](https://test-api.configcat.com/docs/v1/swagger.json) - [Swagger v2](https://test-api.configcat.com/docs/v1/swagger.v2.json)  You can use it to generate client libraries in various languages with [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator) or [Swagger Codegen](https://swagger.io/tools/swagger-codegen/) to interact with this API.  # Authentication This API uses the [Basic HTTP Authentication Scheme](https://en.wikipedia.org/wiki/Basic_access_authentication).   <!-- ReDoc-Inject: <security-definitions> -->  # Throttling and rate limits All the rate limited API calls are returning information about the current rate limit period in the following HTTP headers:  | Header | Description | | :- | :- | | X-Rate-Limit-Remaining | The maximum number of requests remaining in the current rate limit period. | | X-Rate-Limit-Reset     | The time when the current rate limit period resets.        |  When the rate limit is exceeded by a request, the API returns with a `HTTP 429 - Too many requests` status along with a `Retry-After` HTTP header. 

API version: v1
Contact: support@configcat.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package configcatpublicapi

import (
	"encoding/json"
)

// checks if the FeatureFlagLimitations type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &FeatureFlagLimitations{}

// FeatureFlagLimitations Subscription limitations regarding Feature flag or Setting values and targeting.
type FeatureFlagLimitations struct {
	// Maximum number of percentage options a Feature Flag or Setting can have within a targeting rule.
	MaxPercentageOptionCount *int32 `json:"maxPercentageOptionCount,omitempty"`
	// Maximum number of targeting rules a Feature Flag or Setting can have.
	MaxTargetingRuleCount *int32 `json:"maxTargetingRuleCount,omitempty"`
	// Maximum length of a text comparison value.
	MaxComparisonValueLength *int32 `json:"maxComparisonValueLength,omitempty"`
	// Maximum item count of a list comparison value.
	MaxComparisonValueListLength *int32 `json:"maxComparisonValueListLength,omitempty"`
	// Maximum length of a list comparison value's item.
	MaxComparisonValueListItemLength *int32 `json:"maxComparisonValueListItemLength,omitempty"`
	// Maximum length of a text Setting's value.
	MaxStringFlagValueLength *int32 `json:"maxStringFlagValueLength,omitempty"`
	// Maximum number of `AND` conditions a Feature Flag or Setting can have within a targeting rule.
	MaxConditionPerTargetingRuleCount *int32 `json:"maxConditionPerTargetingRuleCount,omitempty"`
}

// NewFeatureFlagLimitations instantiates a new FeatureFlagLimitations object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewFeatureFlagLimitations() *FeatureFlagLimitations {
	this := FeatureFlagLimitations{}
	return &this
}

// NewFeatureFlagLimitationsWithDefaults instantiates a new FeatureFlagLimitations object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewFeatureFlagLimitationsWithDefaults() *FeatureFlagLimitations {
	this := FeatureFlagLimitations{}
	return &this
}

// GetMaxPercentageOptionCount returns the MaxPercentageOptionCount field value if set, zero value otherwise.
func (o *FeatureFlagLimitations) GetMaxPercentageOptionCount() int32 {
	if o == nil || IsNil(o.MaxPercentageOptionCount) {
		var ret int32
		return ret
	}
	return *o.MaxPercentageOptionCount
}

// GetMaxPercentageOptionCountOk returns a tuple with the MaxPercentageOptionCount field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *FeatureFlagLimitations) GetMaxPercentageOptionCountOk() (*int32, bool) {
	if o == nil || IsNil(o.MaxPercentageOptionCount) {
		return nil, false
	}
	return o.MaxPercentageOptionCount, true
}

// HasMaxPercentageOptionCount returns a boolean if a field has been set.
func (o *FeatureFlagLimitations) HasMaxPercentageOptionCount() bool {
	if o != nil && !IsNil(o.MaxPercentageOptionCount) {
		return true
	}

	return false
}

// SetMaxPercentageOptionCount gets a reference to the given int32 and assigns it to the MaxPercentageOptionCount field.
func (o *FeatureFlagLimitations) SetMaxPercentageOptionCount(v int32) {
	o.MaxPercentageOptionCount = &v
}

// GetMaxTargetingRuleCount returns the MaxTargetingRuleCount field value if set, zero value otherwise.
func (o *FeatureFlagLimitations) GetMaxTargetingRuleCount() int32 {
	if o == nil || IsNil(o.MaxTargetingRuleCount) {
		var ret int32
		return ret
	}
	return *o.MaxTargetingRuleCount
}

// GetMaxTargetingRuleCountOk returns a tuple with the MaxTargetingRuleCount field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *FeatureFlagLimitations) GetMaxTargetingRuleCountOk() (*int32, bool) {
	if o == nil || IsNil(o.MaxTargetingRuleCount) {
		return nil, false
	}
	return o.MaxTargetingRuleCount, true
}

// HasMaxTargetingRuleCount returns a boolean if a field has been set.
func (o *FeatureFlagLimitations) HasMaxTargetingRuleCount() bool {
	if o != nil && !IsNil(o.MaxTargetingRuleCount) {
		return true
	}

	return false
}

// SetMaxTargetingRuleCount gets a reference to the given int32 and assigns it to the MaxTargetingRuleCount field.
func (o *FeatureFlagLimitations) SetMaxTargetingRuleCount(v int32) {
	o.MaxTargetingRuleCount = &v
}

// GetMaxComparisonValueLength returns the MaxComparisonValueLength field value if set, zero value otherwise.
func (o *FeatureFlagLimitations) GetMaxComparisonValueLength() int32 {
	if o == nil || IsNil(o.MaxComparisonValueLength) {
		var ret int32
		return ret
	}
	return *o.MaxComparisonValueLength
}

// GetMaxComparisonValueLengthOk returns a tuple with the MaxComparisonValueLength field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *FeatureFlagLimitations) GetMaxComparisonValueLengthOk() (*int32, bool) {
	if o == nil || IsNil(o.MaxComparisonValueLength) {
		return nil, false
	}
	return o.MaxComparisonValueLength, true
}

// HasMaxComparisonValueLength returns a boolean if a field has been set.
func (o *FeatureFlagLimitations) HasMaxComparisonValueLength() bool {
	if o != nil && !IsNil(o.MaxComparisonValueLength) {
		return true
	}

	return false
}

// SetMaxComparisonValueLength gets a reference to the given int32 and assigns it to the MaxComparisonValueLength field.
func (o *FeatureFlagLimitations) SetMaxComparisonValueLength(v int32) {
	o.MaxComparisonValueLength = &v
}

// GetMaxComparisonValueListLength returns the MaxComparisonValueListLength field value if set, zero value otherwise.
func (o *FeatureFlagLimitations) GetMaxComparisonValueListLength() int32 {
	if o == nil || IsNil(o.MaxComparisonValueListLength) {
		var ret int32
		return ret
	}
	return *o.MaxComparisonValueListLength
}

// GetMaxComparisonValueListLengthOk returns a tuple with the MaxComparisonValueListLength field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *FeatureFlagLimitations) GetMaxComparisonValueListLengthOk() (*int32, bool) {
	if o == nil || IsNil(o.MaxComparisonValueListLength) {
		return nil, false
	}
	return o.MaxComparisonValueListLength, true
}

// HasMaxComparisonValueListLength returns a boolean if a field has been set.
func (o *FeatureFlagLimitations) HasMaxComparisonValueListLength() bool {
	if o != nil && !IsNil(o.MaxComparisonValueListLength) {
		return true
	}

	return false
}

// SetMaxComparisonValueListLength gets a reference to the given int32 and assigns it to the MaxComparisonValueListLength field.
func (o *FeatureFlagLimitations) SetMaxComparisonValueListLength(v int32) {
	o.MaxComparisonValueListLength = &v
}

// GetMaxComparisonValueListItemLength returns the MaxComparisonValueListItemLength field value if set, zero value otherwise.
func (o *FeatureFlagLimitations) GetMaxComparisonValueListItemLength() int32 {
	if o == nil || IsNil(o.MaxComparisonValueListItemLength) {
		var ret int32
		return ret
	}
	return *o.MaxComparisonValueListItemLength
}

// GetMaxComparisonValueListItemLengthOk returns a tuple with the MaxComparisonValueListItemLength field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *FeatureFlagLimitations) GetMaxComparisonValueListItemLengthOk() (*int32, bool) {
	if o == nil || IsNil(o.MaxComparisonValueListItemLength) {
		return nil, false
	}
	return o.MaxComparisonValueListItemLength, true
}

// HasMaxComparisonValueListItemLength returns a boolean if a field has been set.
func (o *FeatureFlagLimitations) HasMaxComparisonValueListItemLength() bool {
	if o != nil && !IsNil(o.MaxComparisonValueListItemLength) {
		return true
	}

	return false
}

// SetMaxComparisonValueListItemLength gets a reference to the given int32 and assigns it to the MaxComparisonValueListItemLength field.
func (o *FeatureFlagLimitations) SetMaxComparisonValueListItemLength(v int32) {
	o.MaxComparisonValueListItemLength = &v
}

// GetMaxStringFlagValueLength returns the MaxStringFlagValueLength field value if set, zero value otherwise.
func (o *FeatureFlagLimitations) GetMaxStringFlagValueLength() int32 {
	if o == nil || IsNil(o.MaxStringFlagValueLength) {
		var ret int32
		return ret
	}
	return *o.MaxStringFlagValueLength
}

// GetMaxStringFlagValueLengthOk returns a tuple with the MaxStringFlagValueLength field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *FeatureFlagLimitations) GetMaxStringFlagValueLengthOk() (*int32, bool) {
	if o == nil || IsNil(o.MaxStringFlagValueLength) {
		return nil, false
	}
	return o.MaxStringFlagValueLength, true
}

// HasMaxStringFlagValueLength returns a boolean if a field has been set.
func (o *FeatureFlagLimitations) HasMaxStringFlagValueLength() bool {
	if o != nil && !IsNil(o.MaxStringFlagValueLength) {
		return true
	}

	return false
}

// SetMaxStringFlagValueLength gets a reference to the given int32 and assigns it to the MaxStringFlagValueLength field.
func (o *FeatureFlagLimitations) SetMaxStringFlagValueLength(v int32) {
	o.MaxStringFlagValueLength = &v
}

// GetMaxConditionPerTargetingRuleCount returns the MaxConditionPerTargetingRuleCount field value if set, zero value otherwise.
func (o *FeatureFlagLimitations) GetMaxConditionPerTargetingRuleCount() int32 {
	if o == nil || IsNil(o.MaxConditionPerTargetingRuleCount) {
		var ret int32
		return ret
	}
	return *o.MaxConditionPerTargetingRuleCount
}

// GetMaxConditionPerTargetingRuleCountOk returns a tuple with the MaxConditionPerTargetingRuleCount field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *FeatureFlagLimitations) GetMaxConditionPerTargetingRuleCountOk() (*int32, bool) {
	if o == nil || IsNil(o.MaxConditionPerTargetingRuleCount) {
		return nil, false
	}
	return o.MaxConditionPerTargetingRuleCount, true
}

// HasMaxConditionPerTargetingRuleCount returns a boolean if a field has been set.
func (o *FeatureFlagLimitations) HasMaxConditionPerTargetingRuleCount() bool {
	if o != nil && !IsNil(o.MaxConditionPerTargetingRuleCount) {
		return true
	}

	return false
}

// SetMaxConditionPerTargetingRuleCount gets a reference to the given int32 and assigns it to the MaxConditionPerTargetingRuleCount field.
func (o *FeatureFlagLimitations) SetMaxConditionPerTargetingRuleCount(v int32) {
	o.MaxConditionPerTargetingRuleCount = &v
}

func (o FeatureFlagLimitations) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o FeatureFlagLimitations) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	// skip: maxPercentageOptionCount is readOnly
	// skip: maxTargetingRuleCount is readOnly
	// skip: maxComparisonValueLength is readOnly
	// skip: maxComparisonValueListLength is readOnly
	// skip: maxComparisonValueListItemLength is readOnly
	// skip: maxStringFlagValueLength is readOnly
	// skip: maxConditionPerTargetingRuleCount is readOnly
	return toSerialize, nil
}

type NullableFeatureFlagLimitations struct {
	value *FeatureFlagLimitations
	isSet bool
}

func (v NullableFeatureFlagLimitations) Get() *FeatureFlagLimitations {
	return v.value
}

func (v *NullableFeatureFlagLimitations) Set(val *FeatureFlagLimitations) {
	v.value = val
	v.isSet = true
}

func (v NullableFeatureFlagLimitations) IsSet() bool {
	return v.isSet
}

func (v *NullableFeatureFlagLimitations) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableFeatureFlagLimitations(val *FeatureFlagLimitations) *NullableFeatureFlagLimitations {
	return &NullableFeatureFlagLimitations{value: val, isSet: true}
}

func (v NullableFeatureFlagLimitations) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableFeatureFlagLimitations) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


